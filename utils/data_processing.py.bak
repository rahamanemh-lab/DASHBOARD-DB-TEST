"""
Fonctions de traitement des donn√©es pour le dashboard de souscriptions.
"""
import pandas as pd
import streamlit as st
import numpy as np
import re
from datetime import datetime


@st.cache_data
def safe_to_numeric(series):
    """Convertit une s√©rie en num√©rique avec gestion des erreurs et diagnostic."""
    if series.empty:
        return series
        
    # Cr√©er une copie pour √©viter de modifier l'original
    result = pd.Series([np.nan] * len(series), index=series.index)
    
    # Ignorer les valeurs nulles
    mask_notna = series.notna()
    if not mask_notna.any():
        return result
    
    # Convertir en cha√Æne et nettoyer
    series_str = series[mask_notna].astype(str)
    
    # Nettoyage avanc√© des valeurs num√©riques
    # D√©tection et traitement des formats num√©riques internationaux
    
    # Afficher les valeurs avant conversion pour diagnostic
    sample_values = series_str.sample(min(5, len(series_str))).tolist()
    st.info(f"Exemples de montants avant conversion: {sample_values}")
    
    # Traitement des montants avec s√©parateurs de milliers et d√©cimaux
    # D√©tection du format des montants (anglais ou fran√ßais)
    # Format anglais: 1,234,567.89 (virgule = s√©parateur de milliers, point = d√©cimal)
    # Format fran√ßais: 1 234 567,89 ou 1.234.567,89 (espace/point = s√©parateur de milliers, virgule = d√©cimal)
    
    # V√©rifier si le format semble √™tre anglais (point comme s√©parateur d√©cimal)
    format_anglais = series_str.str.contains(r'\d+\.\d+').any()
    
    if format_anglais:
        st.success("Format anglais d√©tect√© (ex: 1,234,567.89) - Traitement adapt√©")
        # Supprimer uniquement les virgules (s√©parateurs de milliers en format anglais)
        series_str = series_str.str.replace(',', '', regex=False)
    else:
        st.success("Format fran√ßais d√©tect√© (ex: 1 234 567,89) - Traitement adapt√©")
        # Supprimer les espaces et points (s√©parateurs de milliers en format fran√ßais)
        series_str = series_str.str.replace(' ', '', regex=False)
        series_str = series_str.str.replace('\.', '', regex=True)
        # Remplacer les virgules par des points (s√©parateur d√©cimal en format fran√ßais)
        series_str = series_str.str.replace(',', '.', regex=False)
    
    # 2. Supprimer les espaces, symboles mon√©taires et autres caract√®res non num√©riques
    series_str = series_str.str.replace(r'[\s‚Ç¨$¬£¬•\u20AC]', '', regex=True)
    
    # 3. G√©rer les formats avec points comme s√©parateurs de milliers (1.000.000 -> 1000000)
    # Mais seulement si ce ne sont pas des s√©parateurs d√©cimaux
    # On remplace les points qui sont suivis de 3 chiffres
    series_str = series_str.str.replace(r'(\d+)\.(\d{3}(?!\.\d+))', r'\1\2', regex=True)
    series_str = series_str.str.replace(r'(\d+)\.(\d{3}\.)', r'\1\2', regex=True)
    
    # Afficher les valeurs apr√®s nettoyage pour diagnostic
    st.info(f"Montants apr√®s nettoyage: {series_str.sample(min(5, len(series_str))).tolist()}")

    
    try:
        # Convertir en num√©rique
        numeric_values = pd.to_numeric(series_str, errors='coerce')
        result[mask_notna] = numeric_values
        
        # Diagnostics
        zero_count = (result == 0).sum()
        nan_count = result.isna().sum()
        total = len(result)
        
        if nan_count > 0:
            st.info(f"‚ÑπÔ∏è {nan_count} valeurs n'ont pas pu √™tre converties en nombres sur {total} ({nan_count/total:.1%}).")
            
            # Afficher quelques exemples de valeurs probl√©matiques
            if nan_count > 0:
                problem_values = series[result.isna()].sample(min(5, nan_count)).tolist()
                st.info(f"Exemples de valeurs non converties: {problem_values}")
        
        if zero_count > 0:
            st.info(f"‚ÑπÔ∏è {zero_count} valeurs sont √©gales √† z√©ro sur {total} ({zero_count/total:.1%}).")
        
        # Remplacer les NaN par 0 uniquement si demand√© (par d√©faut oui)
        return result.fillna(0)
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la conversion num√©rique: {str(e)}")
        return pd.Series([0] * len(series), index=series.index)


@st.cache_data
def safe_to_datetime(series):
    """Convertit une s√©rie en datetime avec gestion des erreurs et formats multiples."""
    if series.empty:
        return series
    
    # Cr√©er une copie pour √©viter de modifier l'original
    result = pd.Series([pd.NaT] * len(series), index=series.index)
    
    # Ignorer les valeurs nulles
    mask_notna = series.notna()
    if not mask_notna.any():
        return result
    
    # Convertir les valeurs en cha√Ænes de caract√®res pour uniformiser le traitement
    series_str = series[mask_notna].astype(str)
    
    # Nettoyer les cha√Ænes (supprimer les espaces suppl√©mentaires, etc.)
    series_str = series_str.str.strip()
    
    # Cr√©er un dictionnaire pour stocker les raisons des √©checs de conversion
    conversion_issues = {}
    
    # Pr√©-traitement: nettoyer les cha√Ænes pour les cas sp√©ciaux
    # 1. Ins√©rer un espace entre le texte et les chiffres pour les dates coll√©es au texte
    series_str = series_str.str.replace(r'([A-Za-z])([0-3]?\d[/.-])', r'\1 \2', regex=True)
    
    # Identifier et ignorer les cha√Ænes qui ne sont clairement pas des dates
    # (par exemple, les cha√Ænes contenant des informations de souscription)
    mask_potential_dates = ~series_str.str.contains(r'\d{5,}|\\u20ac|\$|\%|\#')
    non_date_format = mask_notna & ~mask_potential_dates
    if non_date_format.any():
        conversion_issues['format_non_date'] = series_str[non_date_format].tolist()
    
    # Identifier les valeurs qui semblent √™tre des nombres (dates Excel)
    mask_numeric = series_str.str.match(r'^\d+(\.\d+)?$')
    if mask_numeric.any():
        try:
            # Convertir les dates au format Excel
            excel_epoch = pd.Timestamp('1899-12-30')
            numeric_values = pd.to_numeric(series_str[mask_numeric], errors='coerce')
            temp_dates = excel_epoch + pd.to_timedelta(numeric_values, unit='D')
            
            # Ne pas filtrer par ann√©e pour accepter toutes les dates valides
            valid_year_mask = temp_dates.notna()
            if valid_year_mask.any():
                result[mask_notna][mask_numeric][valid_year_mask] = temp_dates[valid_year_mask]
            
            # Enregistrer les dates Excel qui ne sont pas de 2025
            invalid_excel_dates = mask_numeric & ~valid_year_mask
            if invalid_excel_dates.any():
                conversion_issues['excel_dates_non_2025'] = series_str[invalid_excel_dates].tolist()
        except Exception as e:
            conversion_issues['excel_date_error'] = str(e)
    
    # Traiter les formats de date courants
    formats_to_try = [
        # Format sp√©cifique de l'utilisateur (jj/mm/aaaa) - PRIORITAIRE ABSOLU
        '%d/%m/%Y',
        
        # Autres formats europ√©ens (jour/mois/ann√©e) - HAUTE PRIORIT√â
        '%d-%m-%Y', '%d.%m.%Y', 
        
        # Formats courts europ√©ens
        '%d/%m/%y', '%d-%m-%y', '%d.%m.%y',
        
        # Formats avec heure (format europ√©en)
        '%d-%m-%Y %H:%M:%S', '%d-%m-%Y %H:%M',
        '%d/%m/%Y %H:%M:%S', '%d/%m/%Y %H:%M', 
        
        # Formats textuels (format europ√©en)
        '%d %B %Y', '%d %b %Y',
        
        # Formats avec jour de la semaine (format europ√©en)
        '%a %d/%m/%Y', '%A %d/%m/%Y', '%a %d %b %Y', '%A %d %B %Y',
        
        # Format ISO - PRIORIT√â MOYENNE
        '%Y-%m-%d', '%Y/%m/%d', '%Y.%m.%d',
        '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M',
        
        # Format am√©ricain (mois/jour/ann√©e) - DERNIER RECOURS
        '%m/%d/%Y', '%m-%d-%Y', '%m.%d.%Y', '%m/%d/%y', '%m-%d-%y', '%m.%d.%y',
        '%B %d, %Y', '%b %d, %Y'
    ]
    
    # Afficher un message d'information sur le format de date attendu
    st.info("""
    ‚ÑπÔ∏è **Format de date attendu**: jj/mm/aaaa (exemple: 15/07/2025)
    
    Autres formats accept√©s (par ordre de priorit√©):
    - jj/mm/aaaa (15/07/2025)
    - jj.mm.aaaa (15.07.2025)
    - Formats avec heure: jj/mm/aaaa HH:MM:SS
    """)
    
    # Essayer les formats un par un
    remaining_mask = mask_notna & result.isna() & mask_potential_dates
    format_success_count = {}
    
    # Essayer d'abord pandas auto-detection (tr√®s robuste pour les dates)
    if remaining_mask.any():
        try:
            # Utiliser pandas pour d√©tecter automatiquement le format
            temp_result = pd.to_datetime(series_str[remaining_mask], errors='coerce')
            valid_mask = temp_result.notna()
            if valid_mask.any():
                result[remaining_mask.index[valid_mask]] = temp_result[valid_mask]
                format_success_count['auto_detect'] = valid_mask.sum()
                # Mettre √† jour le masque pour les valeurs restantes
                remaining_mask = mask_notna & result.isna() & mask_potential_dates
        except Exception as e:
            conversion_issues['auto_detect_error'] = str(e)
    
    # Ensuite essayer les formats sp√©cifiques un par un
    if remaining_mask.any():
        for date_format in formats_to_try:
            try:
                # Mettre √† jour uniquement les valeurs qui n'ont pas encore √©t√© converties
                temp_result = pd.to_datetime(series_str[remaining_mask], format=date_format, errors='coerce')
                valid_mask = temp_result.notna()
                if valid_mask.any():
                    result[remaining_mask.index[valid_mask]] = temp_result[valid_mask]
                    format_success_count[date_format] = valid_mask.sum()
                    # Mettre √† jour le masque pour les valeurs restantes
                    remaining_mask = mask_notna & result.isna() & mask_potential_dates
                    if not remaining_mask.any():
                        break
            except Exception as e:
                conversion_issues[f'format_error_{date_format}'] = str(e)
                continue
    
    # Pour les valeurs restantes, essayer la d√©tection automatique avec dayfirst=True pour forcer le format europ√©en
    remaining_mask = mask_notna & result.isna() & mask_potential_dates
    if remaining_mask.any():
        try:
            # Forcer l'interpr√©tation au format europ√©en (jour en premier)
            temp_result = pd.to_datetime(series_str[remaining_mask], dayfirst=True, errors='coerce')
            valid_mask = temp_result.notna()
            if valid_mask.any():
                result[remaining_mask.index[valid_mask]] = temp_result[valid_mask]
                format_success_count['auto_detect_dayfirst'] = valid_mask.sum()
                remaining_mask = mask_notna & result.isna() & mask_potential_dates
        except Exception as e:
            conversion_issues['auto_detect_error'] = str(e)
            
    # Afficher les formats de date qui ont fonctionn√©
    if format_success_count:
        st.success(f"Formats de date d√©tect√©s avec succ√®s: {format_success_count}")
        
        # Si le format principal (jj/mm/aaaa) n'a pas √©t√© d√©tect√©, afficher un avertissement
        if '%d/%m/%Y' not in format_success_count:
            st.warning("""
            ‚ö†Ô∏è Le format de date principal (jj/mm/aaaa) n'a pas √©t√© d√©tect√© dans votre fichier.
            Pour de meilleurs r√©sultats, utilisez le format jj/mm/aaaa (exemple: 15-07-2025).
            """)
    
    # Extraction avanc√©e pour les formats complexes (par exemple "Entretien Visio21/06/2025 18:00")
    remaining_mask = mask_notna & result.isna()
    pattern_matches = 0
    if remaining_mask.any():
        # Recherche de motifs de date dans les cha√Ænes complexes
        for idx in remaining_mask.index[remaining_mask]:
            text = series_str.loc[idx]
            
            # Recherche de dates au format JJ/MM/AAAA ou jj/mm/aaaa
            date_patterns = [
                r'(\d{1,2}/\d{1,2}/\d{4})',      # Format sp√©cifique jj/mm/aaaa
                r'(\d{1,2}[/.-]\d{1,2}[/.-]\d{2,4})',  # JJ/MM/AAAA ou jj/mm/aaaa
                r'(\d{1,2}\s+[a-zA-Z√©√ª]+\s+\d{2,4})'   # JJ mois AAAA
            ]
            
            pattern_found = False
            for pattern in date_patterns:
                match = re.search(pattern, text)
                if match:
                    pattern_found = True
                    date_str = match.group(1)
                    try:
                        # Essayer de convertir la date extraite
                        date_obj = pd.to_datetime(date_str, errors='coerce')
                        if pd.notna(date_obj):
                            result.loc[idx] = date_obj
                            pattern_matches += 1
                            break
                    except Exception:
                        continue
            
            if not pattern_found:
                # Si aucun motif n'a √©t√© trouv√©, enregistrer la valeur
                if 'no_pattern_match' not in conversion_issues:
                    conversion_issues['no_pattern_match'] = []
                conversion_issues['no_pattern_match'].append(text)
    
    # Diagnostic des valeurs non converties
    non_converted = mask_notna & result.isna()
    if non_converted.any():
        non_converted_count = non_converted.sum()
        total_count = mask_notna.sum()
        if non_converted_count > 0:
            # Afficher un avertissement si plus de 10% des valeurs n'ont pas √©t√© converties
            if non_converted_count > total_count * 0.1:
                st.warning(f"‚ö†Ô∏è {non_converted_count} valeurs de date sur {total_count} n'ont pas pu √™tre converties.")
                # Afficher les statistiques de conversion
                st.expander("üìä D√©tails des probl√®mes de conversion de dates", expanded=False).write({
                    "Formats r√©ussis": format_success_count,
                    "Probl√®mes de conversion": conversion_issues,
                    "Exemples de valeurs probl√©matiques": series[non_converted].sample(min(10, non_converted_count)).tolist()
                })
    
    # Afficher les statistiques sur les ann√©es trouv√©es, mais ne pas filtrer
    if result.notna().any():
        years_found = result[result.notna()].dt.year.value_counts().to_dict()
        # Trier les ann√©es par ordre croissant pour une meilleure lisibilit√©
        years_found = {k: years_found[k] for k in sorted(years_found.keys())}
        
        # Afficher un message informatif sur les ann√©es trouv√©es
        if len(years_found) > 1:
            st.info(f"üìÖ Ann√©es trouv√©es dans les dates: {years_found}")
            
            # Sugg√©rer l'ann√©e la plus fr√©quente
            most_common_year = max(years_found.items(), key=lambda x: x[1])[0]
            st.info(f"üí° L'ann√©e la plus fr√©quente est {most_common_year}. Si toutes les dates devraient √™tre de 2025, v√©rifiez le format de vos dates.")
    
    # Ne pas filtrer par ann√©e - garder toutes les dates valides
    # Si vous souhaitez r√©activer le filtrage par ann√©e, d√©commentez les lignes ci-dessous
    # valid_dates_mask = result.notna() & (result.dt.year == 2025)
    # invalid_year_mask = result.notna() & (result.dt.year != 2025)
    # result[invalid_year_mask] = pd.NaT
    
    return result


def adjust_dates_to_month_range(df, date_column):
    """Ajuste les dates pour avoir une plage compl√®te du 1er au dernier jour du mois.
    
    Args:
        df (DataFrame): DataFrame contenant les dates √† ajuster
        date_column (str): Nom de la colonne contenant les dates
        
    Returns:
        DataFrame: DataFrame avec les colonnes ajout√©es:
            - 'Mois': Format 'YYYY-MM'
            - 'Premier_Jour_Mois': Premier jour du mois (date)
            - 'Dernier_Jour_Mois': Dernier jour du mois (date)
    """
    # V√©rifier si la colonne existe
    if date_column not in df.columns:
        st.error(f"‚ùå Colonne {date_column} non trouv√©e dans les donn√©es.")
        return df
    
    # Convertir la colonne en datetime si ce n'est pas d√©j√† fait
    if not pd.api.types.is_datetime64_dtype(df[date_column]):
        df[date_column] = safe_to_datetime(df[date_column])
    
    # Cr√©er une colonne 'Mois' au format 'YYYY-MM'
    df['Mois'] = df[date_column].dt.strftime('%Y-%m')
    
    # Cr√©er une colonne avec le premier jour du mois
    df['Premier_Jour_Mois'] = df[date_column].dt.to_period('M').dt.to_timestamp()
    
    # Cr√©er une colonne avec le dernier jour du mois
    # Astuce: ajouter 1 mois au premier jour puis soustraire 1 jour
    df['Dernier_Jour_Mois'] = (df['Premier_Jour_Mois'] + pd.DateOffset(months=1) - pd.DateOffset(days=1))
    
    return df


def extract_conseiller(df, column=None):
    """Extrait le nom du conseiller √† partir d'une colonne sp√©cifi√©e ou recherche parmi plusieurs colonnes possibles.
    
    Args:
        df: DataFrame contenant les donn√©es
        column: Nom de la colonne contenant l'information du conseiller (optionnel)
        
    Returns:
        DataFrame avec une colonne 'Conseiller' standardis√©e
    """
    # Liste des noms de colonnes possibles pour le conseiller
    # Prioriser la colonne exacte 'Conseiller' fournie par l'utilisateur
    possible_columns = [
        # Colonne exacte de l'utilisateur en priorit√©
        'Conseiller',
        # Autres variantes possibles
        'conseiller', 'CONSEILLER',
        'Conseiller', 'Conseiller', 'Conseiller',
        'Agent', 'agent', 'AGENT',
        'Vendeur', 'vendeur', 'VENDEUR',
        'Commercial', 'commercial', 'COMMERCIAL',
        'Staff', 'staff', 'STAFF',
        'User', 'user', 'USER',
        'Utilisateur', 'utilisateur', 'UTILISATEUR',
        'Conseiller affect√©', 'conseiller affect√©', 'CONSEILLER AFFECT√â',
        'Assigned Conseiller', 'assigned Conseiller', 'ASSIGNED Conseiller'
    ]
    
    # Si une colonne sp√©cifique est fournie, l'utiliser
    if column and column in df.columns:
        df['Conseiller'] = df[column].fillna('Inconnu')
    else:
        # Sinon, rechercher parmi les colonnes possibles
        found = False
        for col in possible_columns:
            if col in df.columns and df[col].notna().any():
                df['Conseiller'] = df[col].fillna('Inconnu')
                found = True
                break
        
        # Si aucune colonne n'est trouv√©e, cr√©er une colonne par d√©faut
        if not found:
            st.warning("‚ö†Ô∏è Aucune colonne de conseiller trouv√©e. Utilisation de 'Inconnu' par d√©faut.")
            df['Conseiller'] = 'Inconnu'
    
    # Nettoyer les valeurs
    if 'Conseiller' in df.columns:
        # Extraire le nom du conseiller si au format "Conseiller 'Nom'" ou "Conseiller 'Nom'"
        pattern = r"(?:Conseiller|Conseiller|Agent|Staff|Par|Commercial|Vendeur)['\s:]*([^']+)['\s]*"
        mask = df['Conseiller'].astype(str).str.contains(pattern, case=False, regex=True)
        if mask.any():
            df.loc[mask, 'Conseiller'] = df.loc[mask, 'Conseiller'].astype(str).str.extract(pattern, expand=False)
        
        # Nettoyer les espaces et remplacer les valeurs vides
        df['Conseiller'] = df['Conseiller'].astype(str).str.strip().replace('', 'Inconnu').fillna('Inconnu')
    
    return df


def nettoyer_email(email_series):
    """Nettoie une s√©rie d'emails en les mettant en minuscules et en supprimant les espaces."""
    if email_series.dtype != object:
        return email_series
    return email_series.str.lower().str.strip()


def read_excel_robust(uploaded_file, header=0):
    """Tente de lire un fichier Excel avec diff√©rentes m√©thodes et moteurs.
    
    Args:
        uploaded_file: Fichier t√©l√©charg√© via st.file_uploader
        header: Index de la ligne d'en-t√™te (par d√©faut 0)
        
    Returns:
        DataFrame: Donn√©es du fichier Excel
        
    Raises:
        Exception: Si aucune m√©thode ne fonctionne
    """
    error_messages = []
    
    # M√©thode 1: Lecture directe avec pandas
    try:
        df = pd.read_excel(uploaded_file, header=header)
        st.success("‚úÖ Fichier lu avec succ√®s (m√©thode directe pandas)")
        return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"M√©thode directe pandas: {str(e)}")
    
    # M√©thode 2: Utiliser openpyxl comme moteur
    try:
        df = pd.read_excel(uploaded_file, header=header, engine='openpyxl')
        st.success("‚úÖ Fichier lu avec succ√®s (moteur openpyxl)")
        return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"Moteur openpyxl: {str(e)}")
    
    # M√©thode 3: Utiliser xlrd comme moteur
    try:
        df = pd.read_excel(uploaded_file, header=header, engine='xlrd')
        st.success("‚úÖ Fichier lu avec succ√®s (moteur xlrd)")
        return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"Moteur xlrd: {str(e)}")
    
    # M√©thode 4: Utiliser BytesIO
    try:
        import io
        bytes_data = uploaded_file.getvalue()
        df = pd.read_excel(io.BytesIO(bytes_data), header=header)
        st.success("‚úÖ Fichier lu avec succ√®s (m√©thode BytesIO)")
        return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"M√©thode BytesIO: {str(e)}")
    
    # M√©thode 5: Sauvegarder temporairement et lire
    try:
        import tempfile
        import os
        with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp:
            tmp.write(uploaded_file.getvalue())
            tmp_path = tmp.name
        
        df = pd.read_excel(tmp_path, header=header)
        os.unlink(tmp_path)  # Supprimer le fichier temporaire
        st.success("‚úÖ Fichier lu avec succ√®s (m√©thode fichier temporaire)")
        return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"M√©thode fichier temporaire: {str(e)}")
        try:
            os.unlink(tmp_path)  # Essayer de supprimer le fichier temporaire en cas d'erreur
        except:
            pass
    
    # M√©thode 6: Essayer de lire comme CSV
    try:
        df = pd.read_csv(uploaded_file, header=header)
        st.success("‚úÖ Fichier lu avec succ√®s (format CSV)")
        return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"Format CSV: {str(e)}")
    
    # M√©thode 7: Essayer de lire toutes les feuilles
    try:
        all_sheets = pd.read_excel(uploaded_file, sheet_name=None, header=header)
        if all_sheets:
            # Prendre la premi√®re feuille
            sheet_name = list(all_sheets.keys())[0]
            df = all_sheets[sheet_name]
            st.success(f"‚úÖ Fichier lu avec succ√®s (feuille: {sheet_name})")
            return clean_dataframe(df)
    except Exception as e:
        error_messages.append(f"Lecture multi-feuilles: {str(e)}")
    
    # Si toutes les m√©thodes √©chouent, afficher les erreurs et lever une exception
    error_details = "\n".join(error_messages)
    st.error(f"‚ùå Impossible de lire le fichier Excel. Erreurs rencontr√©es:\n{error_details}")
    raise Exception(f"Impossible de lire le fichier Excel apr√®s plusieurs tentatives:\n{error_details}")


def clean_dataframe(df):
    """Nettoie un DataFrame en supprimant les colonnes vides et les colonnes 'Unnamed'."""
    # Supprimer les colonnes vides
    df = df.dropna(axis=1, how='all')
    
    # Supprimer les colonnes 'Unnamed'
    df = df.loc[:, ~df.columns.str.contains('^Unnamed')]
    
    # Supprimer les lignes enti√®rement vides
    df = df.dropna(how='all')
    
    return df
